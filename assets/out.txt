[{"串讲23种设计模式":"behavioural 11 种\n\n1. Memento（备忘录）\n\n精巧程度： 5星\n\n应用广泛：2星\n\nmemento适合保存/恢复状态的场景。分为宽接口和窄接口。学习就要学窄接口！\n\n具体请见： http://www.blogjava.net/vcycyv/archive/2011/02/08/343949.html\n\n \n\n2. Chain of Responsibility(责任链)\n\n精巧程度： 3星\n\n应用广泛： 3星\n\n适合用在\"一系列handler”的场景下。分为纯和不纯两种，好像女孩儿也可以这么分？\n\n具体请见：\n\nhttp://www.blogjava.net/vcycyv/archive/2011/02/12/344167.html\n\n \n\n3. Observer（观察者）\n\n因为java里有Obserable和Observer， 所以通常在java里不会自己设计观察者模式。\n\n \n\n4. Command(命令模式)\n\n精巧程度：4星\n\n应用广泛：3星\n\ncommand模式用来解耦invoker和receiver.\n\n具体请见：\n\nhttp://www.blogjava.net/vcycyv/archive/2011/02/12/344168.html\n\n \n\n5. State(状态模式)\n\n精巧程度：4星\n\n应用广泛：3星\n\nOO编程如果出现多个相同的if…else条件，应该考虑用state模式重构。work flow的状态器也是基于State模式的。\n\n具体请见：\n\nhttp://www.blogjava.net/vcycyv/archive/2011/02/09/343998.html\n\n \n\n6. Interpreter\n\n精巧程度： N/A\n\n应用广泛： 1星\n\n据说只有搜索引擎才用得上这个模式，反正我每次学设计模式的时候，都把这个跳过去，就是不喜欢，抱歉。\n\n \n\n7. Strategy（策略模式）\n\n精巧程度： 2星\n\n应用广泛：4星\n\n用来封装不同算法。从uml图上看和state模式一样。 因为这个太简单了，所以没记笔记，这个忘不了。\n\n \n\n8. Iterator(迭代子)\n\nJava Collection都可以迭代，在java上不需要格外设计iterator。\n\n \n\n9. Template Method(模板方法)\n\n精巧程度：2星\n\n应用广泛：4星\n\n见名知义。太简单了，学过一遍就不会忘。但是这个应用非常广泛！\n\n \n\n10. Mediator(仲裁者)\n\n精巧程度：4星\n\n应用广泛：1星\n\n用来解耦多个peer。个人觉得这个模式多半会让mediator十分臃肿，mediator本身需要有很清晰的设计才能使用。应用场景恐怕也少。\n\n具体请见：\n\nhttp://www.blogjava.net/vcycyv/archive/2011/02/08/343951.html\n\n \n\n11. Visitor(访问者)\n\n精巧程度：5星\n\n应用广泛：2星\n\ncollection里存一个类系的entry时，使用visitor模式可以避免instance of的使用。更重要的是方便扩展类系。\n\n具体请见：\n\nhttp://www.blogjava.net/vcycyv/archive/2011/02/13/344194.html\n\n \n\nStructure 7种\n\n12. adapter(适配器)\n\n精巧程度：2星\n\n应用广泛：1星\n\n个人觉得Adaptee由第三方提供的时候才可能用上这个模式[vcycyv编辑：后来意识到，这个评论不客观。adaptee实现核心功能，通过adapter暴露多种访问方式的情况下，adaptee也是自己写的，而不是第三方的]。简单应用范围又窄，略\n\n \n\n13. Proxy(代理)\n\n精巧程度：2星\n\n应用广泛：5星\n\naop是代理模式的一种发挥。Spring和Hibernate都大量使用proxy。可以引申学学JDK的dynamic proxy。模式简单，略。\n\n \n\n14. Bridge\n\n精巧程度： 5星\n\n应用广泛： 3星\n\nBridge在技术上是strategy的进一步发挥，但侧重在实现与抽象的解耦。\n\n具体见：\n\nhttp://www.blogjava.net/vcycyv/archive/2011/02/08/343950.html\n\n \n\n15. Composite\n\n精巧程度： 4星\n\n应用广泛： 3星\n\n适用于树状结构。\n\n具体见：\n\nhttp://www.blogjava.net/vcycyv/archive/2011/02/13/344209.html\n\n \n\n16. Decorator(装饰)\n\n精巧程度： 5星\n\n应用广泛：3星\n\n在java I/O中广泛使用。为了解决“类爆炸”的问题。\n\n具体请见：\n\nhttp://www.blogjava.net/vcycyv/archive/2011/02/09/343997.html\n\n \n\n17. Facade(门面)\n\n连个UML图都没有，算神马模式？\n\n \n\n18. Flyweight\n\n精巧程度：5星\n\n应用广泛：2星\n\n分“单纯”“复合”两种，本身包含了工厂方法模式。一系列对象如果他们都有某部分属于特定集合，就让他们共享这个特定集合以节省资源。\n\n具体请见：\n\nhttp://www.blogjava.net/vcycyv/archive/2011/02/12/344169.html\n\n \n\nCreational 6 种\n\n19. Factory Method(工厂方法)\n\n精巧程度：3星\n\n应用广泛：4星\n\n两个变种，一个是根据参数创建对象，一个是factory类系对应产品类系。面向接口编程在创建模式的体现。\n\n具体请见：\n\nhttp://www.blogjava.net/vcycyv/archive/2011/02/13/344176.html\n\n \n\n20. Abstract Factory（抽象工厂）\n\n精巧程度：5星\n\n应用广泛：1星\n\n只有产品有两个类系的时候才用得上。\n\n具体请见：\n\nhttp://www.blogjava.net/vcycyv/archive/2011/02/15/344390.html\n\n \n\n21. Builder\n\n精巧程度： 5星\n\n应用广泛： 2星\n\n产品分部分，并且build的过程不定的时候考虑用这种模式。是模板模式的一种发挥\n\n具体请见：\n\nhttp://www.blogjava.net/vcycyv/archive/2011/02/09/343995.html\n\n \n\n22. Prototype(原型)\n\njava有cloneable的支持，所以通常不需要自己设计prototype. java用prototype的时候注意深复制浅复制的问题。prototype之外的一个选择是提供一个constructor接受本类型对象作为参数，这个方式更加实用！\n\n \n\n23. singleton(单态)\n\n古典的singleton分为懒汉，饿汉两种。JDK1.5之后可以用唯一entry 的enum作为singleton的实现。好处有两点，一是简单。二是不需要格外处理serializable的情况"}]