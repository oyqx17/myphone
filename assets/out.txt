[{"listview加载adapter过程是这样的．":"１　先判断adapter 有多少数据项，根据这个数据确定有多少item. \n２　确定每个item里加载哪个View.　\n３　把View里加载要显示的数据．"},{"public class WeatherAdapter extends BaseAdapter {   ":" private Context context;   \n    private List<Weather> weatherList;   　这就是adapter关联的List，用来存储数据．还记的ArrayList　要往里传参数吗？　传的也是这个类型啊．呵呵\n  \n    public WeatherAdapter(Context context, List<Weather> weatherList ) {    \n        this.context = context;   \n        this.weatherList = weatherList;   \n    }   \n  \n    public int getCount() {                           \n        return weatherList.size();   \n    }   \n  \n    public Object getItem(int position) {        \n        return weatherList.get(position);   \n    }   \n  \n    public long getItemId(int position) {     \n        return position;   \n    }   \n  \n    public View getView(int position, View convertView, ViewGroup parent) {    \n        Weather weather = weatherList.get(position);   \n        return new WeatherAdapterView(this.context, weather );   \n    }   "},{"class WeatherAdapterView extends LinearLayout {   ":" public static final String LOG_TAG = \"WeatherAdapterView\";   \n  \n        public WeatherAdapterView(Context context,    \n                                Weather weather ) {   \n            super( context );   \n  \n            this.setOrientation(HORIZONTAL);           \n            LinearLayout.LayoutParams cityParams =    \n                new LinearLayout.LayoutParams(100, LayoutParams.WRAP_CONTENT);   \n            cityParams.setMargins(1, 1, 1, 1);   \n  \n            TextView cityControl = new TextView( context );   \n            cityControl.setText( weather.getCity() );   \n            addView( cityControl, cityParams);          \n  \n            LinearLayout.LayoutParams temperatureParams =    \n                new LinearLayout.LayoutParams(20, LayoutParams.WRAP_CONTENT);   \n            temperatureParams.setMargins(1, 1, 1, 1);   \n  \n            TextView temperatureControl = new TextView(context);   \n            temperatureControl.setText( Integer.toString( weather.temperature ) );   \n            addView( temperatureControl, temperatureParams);               \n  \n            LinearLayout.LayoutParams skyParams =    \n                new LinearLayout.LayoutParams(25, LayoutParams.WRAP_CONTENT);   \n  \n            ImageView skyControl = new ImageView( context );   \n            Log.d( LOG_TAG, weather.getCity()+\" -> \"+weather.sky );   \n            skyControl.setImageResource( weather.getSkyResource() );   \n            addView( skyControl, skyParams );   \n        }   \n}   "},{"Producer and comsumer with DataInputStream and DataOutputStream":"import java.io.DataInputStream;\nimport java.io.DataOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PipedInputStream;\nimport java.io.PipedOutputStream;\n\npublic class MainClass {\n\n  public static void main (String[] args) throws IOException {\n    PipedOutputStream pout = new PipedOutputStream();\n    PipedInputStream pin = new PipedInputStream(pout);\n\n    NumberProducer fw = new NumberProducer(pout, 20);\n    NumberConsumer fr = new NumberConsumer(pin);\n    fw.start();\n    fr.start();\n  }\n}\n\nclass NumberProducer extends Thread {\n  private DataOutputStream theOutput;\n  private int howMany;\n\n  public NumberProducer(OutputStream out, int howMany) {\n    theOutput = new DataOutputStream(out);\n    this.howMany = howMany;\n  }\n\n  public void run() {\n    try {\n      for (int i = 0; i < howMany; i++) {\n        theOutput.writeInt(i);\n      }\n    }\n    catch (IOException ex) { System.err.println(ex); }\n  }\n}\n\n class NumberConsumer extends Thread {\n\n  private DataInputStream theInput;\n\n  public NumberConsumer(InputStream in) {\n    theInput = new DataInputStream(in);\n  }\n\n  public void run() {\n\n    try {\n      while (true) {\n        System.out.println(theInput.readInt());\n      }\n    }\n    catch (IOException ex) {\n      if (ex.getMessage().equals(\"Pipe broken\")\n        || ex.getMessage().equals(\"Write end dead\")) {\n        // normal termination\n        return;\n      }\n      ex.printStackTrace();\n    }\n  }\n}"},{"生产者，消费者和队列":"import java.util.Vector;\n\nclass Producer extends Thread {\n  Queue queue;\n  Producer(Queue queue) {\n    this.queue = queue;\n  }\n  public void run() {\n    int i = 0;\n    while(true) {\n      queue.add(i++);\n    }\n  }\n}\nclass Consumer extends Thread {\n  String str;\n  Queue queue;\n  Consumer(String str, Queue queue) {\n    this.str = str;\n    this.queue = queue;\n  }\n\n  public void run() {\n    while(true) {\n      System.out.println(str + \": \" + queue.remove());\n    }\n  }\n}\n\nclass Queue {\n  private final static int SIZE = 5;\n  private Vector queue = new Vector();\n  private int count = 0;\n  \n  synchronized void add(int i) {\n    while(count == SIZE) {\n      try {\n        wait();\n      }\n      catch(InterruptedException ie) {\n        ie.printStackTrace();\n        System.exit(0);\n      }\n    }\n    queue.addElement(new Integer(i));\n    ++count;\n    notifyAll();\n  }\n  synchronized int remove() {\n    while(count == 0) {\n      try {\n        wait();\n      }\n      catch(InterruptedException ie) {\n        ie.printStackTrace();\n        System.exit(0);\n      }\n    }\n    Integer iobj = (Integer)queue.firstElement();\n    queue.removeElement(iobj);\n    --count;\n    notifyAll();\n    return iobj.intValue();\n  }\n}\n\nclass ProducerConsumers {\n  public static void main(String args[]) {\n    Queue queue = new Queue();\n    new Producer(queue).start();\n    new Consumer(\"ConsumerA\", queue).start();\n    new Consumer(\"ConsumerB\", queue).start();\n    new Consumer(\"ConsumerC\", queue).start();\n  }\n}"},{"同步队列与生产者和消费者":"public class ThreadTester {\n  public static void main(String[] args) {\n    SynchronizedQueue<String> queue = new SynchronizedQueue<String>(10);\n    final int GREETING_COUNT = 100;\n    Runnable run1 = new Producer(\"Hello, World!\", queue, GREETING_COUNT);\n    Runnable run2 = new Producer(\"Goodbye, World!\", queue, GREETING_COUNT);\n    Runnable run3 = new Consumer(queue, 2 * GREETING_COUNT);\n\n    Thread thread1 = new Thread(run1);\n    Thread thread2 = new Thread(run2);\n    Thread thread3 = new Thread(run3);\n\n    thread1.start();\n    thread2.start();\n    thread3.start();\n  }\n}\n\nclass Producer implements Runnable {\n  private String greeting;\n  private SynchronizedQueue<String> queue;\n\n  private int greetingCount;\n\n  public Producer(String aGreeting, SynchronizedQueue<String> aQueue, int count) {\n    greeting = aGreeting;\n    queue = aQueue;\n    greetingCount = count;\n  }\n\n  public void run() {\n    try {\n      int i = 1;\n      while (i <= greetingCount) {\n        queue.add(i + \": \" + greeting);\n        i++;\n        Thread.sleep(2000);\n      }\n    } catch (InterruptedException exception) {\n    }\n  }\n\n}\n\nclass Consumer implements Runnable {\n\n  private SynchronizedQueue<String> queue;\n\n  private int greetingCount;\n\n  public Consumer(SynchronizedQueue<String> aQueue, int count) {\n    queue = aQueue;\n    greetingCount = count;\n  }\n\n  public void run() {\n    try {\n      int i = 1;\n      while (i <= greetingCount) {\n        String greeting = queue.remove();\n        System.out.println(greeting);\n        i++;\n        Thread.sleep(3000);\n      }\n    } catch (InterruptedException exception) {\n    }\n  }\n\n}\n\nclass SynchronizedQueue<V> {\n\n  private Object[] elements;\n\n  private int head;\n\n  private int tail;\n\n  private int size;\n\n  public SynchronizedQueue(int capacity) {\n    elements = new Object[capacity];\n    head = 0;\n    tail = 0;\n    size = 0;\n  }\n\n  public synchronized V remove() throws InterruptedException {\n    while (size == 0)\n      wait();\n    V r = (V) elements[head];\n    head++;\n    size--;\n    if (head == elements.length)\n      head = 0;\n    notifyAll();\n    return r;\n  }\n\n  public synchronized void add(V newValue) throws InterruptedException {\n    while (size == elements.length)\n      wait();\n    elements[tail] = newValue;\n    tail++;\n    size++;\n    if (tail == elements.length)\n      tail = 0;\n    notifyAll();\n  }\n\n}"},{"A queue(LinkedList) is used to coordinate work between a producer and a set of worker threads.":"import java.util.LinkedList;\n\npublic class Main {\n  public static void main(String[] argv) {\n    WorkQueue queue = new WorkQueue();\n\n    int numWorkers = 2;\n    Worker[] workers = new Worker[numWorkers];\n    for (int i = 0; i < workers.length; i++) {\n      workers[i] = new Worker(queue);\n      workers[i].start();\n    }\n\n    for (int i = 0; i < 100; i++) {\n      queue.addWork(i);\n    }\n  }\n}\n\nclass WorkQueue {\n  LinkedList<Object> queue = new LinkedList<Object>();\n\n  public synchronized void addWork(Object o) {\n    queue.addLast(o);\n    notify();\n  }\n\n  public synchronized Object getWork() throws InterruptedException {\n    while (queue.isEmpty()) {\n      wait();\n    }\n    return queue.removeFirst();\n  }\n}\n\nclass Worker extends Thread {\n  WorkQueue q;\n\n  Worker(WorkQueue q) {\n    this.q = q;\n  }\n\n  public void run() {\n    try {\n      while (true) {\n        Object x = q.getWork();\n\n        if (x == null) {\n          break;\n        }\n        System.out.println(x);\n      }\n    } catch (InterruptedException e) {\n    }\n  }\n}"},{"创建多个线程":"class NewThread implements Runnable {\n  String name; // name of thread\n\n  Thread t;\n\n  NewThread(String threadname) {\n    name = threadname;\n    t = new Thread(this, name);\n    System.out.println(\"New thread: \" + t);\n    t.start(); // Start the thread\n  }\n\n  public void run() {\n    try {\n      for (int i = 5; i > 0; i--) {\n        System.out.println(name + \": \" + i);\n        Thread.sleep(1000);\n      }\n    } catch (InterruptedException e) {\n      System.out.println(name + \"Interrupted\");\n    }\n    System.out.println(name + \" exiting.\");\n  }\n}\n\nclass MultiThreadDemo {\n  public static void main(String args[]) {\n    new NewThread(\"One\"); // start threads\n    new NewThread(\"Two\");\n    new NewThread(\"Three\");\n\n    try {\n      Thread.sleep(10000);\n    } catch (InterruptedException e) {\n      System.out.println(\"Main thread Interrupted\");\n    }\n\n    System.out.println(\"Main thread exiting.\");\n  }\n}"},{"创建一个线程来更新用户界面":"import java.awt.Color;\nimport java.awt.Font;\nimport java.awt.Graphics;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport java.util.Locale;\n\nimport javax.swing.JFrame;\nimport javax.swing.JPanel;\n\npublic class Clock extends JPanel implements Runnable {\n  Thread thread = null;\n\n  SimpleDateFormat formatter = new SimpleDateFormat(\"s\", Locale.getDefault());\n\n  Date currentDate;\n\n  int xcenter = 100, ycenter = 100, lastxs = 0, lastys = 0, lastxm = 0, lastym = 0, lastxh = 0,\n      lastyh = 0;\n\n  private void drawStructure(Graphics g) {\n    g.setFont(new Font(\"TimesRoman\", Font.PLAIN, 14));\n    g.setColor(Color.blue);\n    g.drawOval(xcenter - 50, ycenter - 50, 100, 100);\n    g.setColor(Color.darkGray);\n    g.drawString(\"9\", xcenter - 45, ycenter + 3);\n    g.drawString(\"3\", xcenter + 40, ycenter + 3);\n    g.drawString(\"12\", xcenter - 5, ycenter - 37);\n    g.drawString(\"6\", xcenter - 3, ycenter + 45);\n\n  }\n\n  public void paint(Graphics g) {\n    int xhour, yhour, xminute, yminute, xsecond, ysecond, second, minute, hour;\n    drawStructure(g);\n\n    currentDate = new Date();\n    \n    formatter.applyPattern(\"s\");\n    second = Integer.parseInt(formatter.format(currentDate));\n    formatter.applyPattern(\"m\");\n    minute = Integer.parseInt(formatter.format(currentDate));\n\n    formatter.applyPattern(\"h\");\n    hour = Integer.parseInt(formatter.format(currentDate));\n\n    xsecond = (int) (Math.cos(second * 3.14f / 30 - 3.14f / 2) * 45 + xcenter);\n    ysecond = (int) (Math.sin(second * 3.14f / 30 - 3.14f / 2) * 45 + ycenter);\n    xminute = (int) (Math.cos(minute * 3.14f / 30 - 3.14f / 2) * 40 + xcenter);\n    yminute = (int) (Math.sin(minute * 3.14f / 30 - 3.14f / 2) * 40 + ycenter);\n    xhour = (int) (Math.cos((hour * 30 + minute / 2) * 3.14f / 180 - 3.14f / 2) * 30 + xcenter);\n    yhour = (int) (Math.sin((hour * 30 + minute / 2) * 3.14f / 180 - 3.14f / 2) * 30 + ycenter);\n\n    // Erase if necessary, and redraw\n    g.setColor(Color.lightGray);\n    if (xsecond != lastxs || ysecond != lastys) {\n      g.drawLine(xcenter, ycenter, lastxs, lastys);\n    }\n    if (xminute != lastxm || yminute != lastym) {\n      g.drawLine(xcenter, ycenter - 1, lastxm, lastym);\n      g.drawLine(xcenter - 1, ycenter, lastxm, lastym);\n    }\n    if (xhour != lastxh || yhour != lastyh) {\n      g.drawLine(xcenter, ycenter - 1, lastxh, lastyh);\n      g.drawLine(xcenter - 1, ycenter, lastxh, lastyh);\n    }\n    \n    g.setColor(Color.darkGray);\n    g.drawLine(xcenter, ycenter, xsecond, ysecond);\n   \n    g.setColor(Color.red);\n    g.drawLine(xcenter, ycenter - 1, xminute, yminute);\n    g.drawLine(xcenter - 1, ycenter, xminute, yminute);\n    g.drawLine(xcenter, ycenter - 1, xhour, yhour);\n    g.drawLine(xcenter - 1, ycenter, xhour, yhour);\n    lastxs = xsecond;\n    lastys = ysecond;\n    lastxm = xminute;\n    lastym = yminute;\n    lastxh = xhour;\n    lastyh = yhour;\n  }\n\n  public void start() {\n    if (thread == null) {\n      thread = new Thread(this);\n      thread.start();\n    }\n  }\n\n  public void stop() {\n    thread = null;\n  }\n\n  public void run() {\n    while (thread != null) {\n      try {\n        Thread.sleep(100);\n      } catch (InterruptedException e) {\n      }\n      repaint();\n    }\n    thread = null;\n  }\n\n  public void update(Graphics g) {\n    paint(g);\n  }\n\n  public static void main(String args[]) {\n    JFrame window = new JFrame();\n    window.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n    window.setBounds(30, 30, 300, 300);\n    Clock clock = new Clock();\n    window.getContentPane().add(clock);\n    window.setVisible(true);\n    clock.start();\n  }\n}"}]